.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "cha\-protocols" "7" "" "" "Protocol support in Chawan"
.SH Protocols
Chawan supports downloading resources from various protocols: HTTP, FTP,
SFTP, Gopher, Gemini, Spartan, and Finger.
Details on these protocols, and information on how users can add support
to their preferred protocols is outlined in this document.
.PP
You can find network adapters in the source distribution\(cqs
\f[CR]adapter/protocol\f[R] directory.
For protocol\-specific file formats (like gemtext or gopher directories)
you will also find an appropriate HTML converter in
\f[CR]adapter/format\f[R].
.SS OpenSSL\-based adapters
The HTTP(S), SFTP, and Gemini modules all depend on OpenSSL.
This is a huge library, and linking it separately with each adapter
would result in enormous code bloat in static builds.
.PP
Therefore, these modules are compiled into a single binary.
The entry point can be found at \f[CR]adapter/protocol/ssl.nim\f[R].
.SS HTTP
The HTTP(S) adapter supports HTTP/1.1 with arbitrary headers and POST
data, is able to use passed userinfo data (Basic authentication), and
returns all headers and response body it receives without exception.
.PP
Deflate decompression with gzip and zlib headers is supported.
(Accept\-Encoding: gzip, deflate.)
This is based on a modified version of the public domain tinfl.h
decompressor by Rich Geldreich.
.PP
Brotli decompression (Accept\-Encoding: br) is supported using the
decoder provided by the reference implementation.
.PP
The \f[CR]bonus\f[R] directory contains two alternative HTTP clients:
.IP \(bu 2
curlhttp; this is the old HTTP client based on libcurl.
It can be built using curl\-impersonate; see README.md in the bonus/
directory for details.
.IP \(bu 2
libfetch\-http: based on FreeBSD libfetch.
It is mostly a proof of concept, as FreeBSD libfetch HTTP support is
very limited; in particular, it does not support arbitrary HTTP headers,
so e.g.
cookies will not work.
.SS SFTP
The SFTP adapter wraps libssh2.
It works for me, but YMMV.
.PP
A slight usability issue is that if an IdentityFile declaration is found
in your ssh config, it will prompt for the identity file password, but
there is no way to tell whether it is really asking for that (or just
regular password auth).
Also, settings covered by the Match field are ignored.
.PP
The adapter does not have a way to register new known hosts, so you have
to first connect to new hosts with the regular \f[CR]sftp\f[R] command
before opening them in Chawan.
.SS Gemini
Currently, the Gemini adapter does not support sites that require
private key authentication.
Otherwise, it should work OK.
.PP
gmi2html is its companion program to convert the \f[CR]text/gemini\f[R]
file format to HTML.
.SS FTP
Chawan supports FTP passive mode browsing and downloads.
.PP
Directory listings return the \f[CR]text/x\-dirlist\f[R] content type,
which is parsed by \f[CR]dirlist2html\f[R] (and also used by the
\f[CR]file:\f[R] handler).
This assumes UNIX output style, and will probably break horribly on
receiving anything else.
.SS Shell\-based adapters
Following protocols are simple enough to have adapters implemented as
shell scripts.
As such, they are good starting points for understanding Chawan\(cqs
protocol adapter system.
.PP
To open TCP connections in a portable manner, these scripts use a very
limited \f[CR]nc\f[R] clone installed in \f[CR]$CHA_LIBEXEC_DIR\f[R].
.SS Gopher
Support for the Gopher protocol is implemented as a shell script, using
the \f[CR]nc\f[R] tool in the libexec directory (a very limited netcat
clone).
Gopher directories are returned with the \f[CR]text/gopher\f[R] type,
and gopher2html takes care of converting this to HTML.
.PP
Gopher selector types are converted to MIME types when possible;
however, this is very limited, as most of them (like \f[CR]s\f[R] sound,
or \f[CR]I\f[R] image) cannot be unambiguously converted without some
other sniffing method.
Chawan will fall back to extension\-based detection in these cases, and
in the worst case may end up with \f[CR]application/octet\-stream\f[R].
.SS Finger
Finger is supported through the \f[CR]finger\f[R] shell script, using
the same \f[CR]nc\f[R] clone as Gopher.
It is probably the simplest protocol of all.
.PP
The URL scheme is a simplified imitation of the one accepted by Lynx.
.SS Spartan
Spartan is a protocol similar to Gemini, but without TLS.
It is supported through the \f[CR]spartan\f[R] shell script, and like
Finger, it uses Chawan\(cqs \f[CR]nc\f[R] to make requests.
.PP
Spartan has the very strange property of extending gemtext with a
protocol\-specific line type.
This is implemented as a sed filter for gemtext outputs in the CGI
script (in other words, no modification to gmi2html was done to support
this).
.SS Local schemes: file:, man:
While these are not necessarily \f[I]protocols\f[R], they are
implemented similarly to the protocols listed above (and thus can also
be replaced, if the user wishes; see below).
.PP
\f[CR]file:\f[R] loads a file from the local filesystem.
In case of directories, it shows the directory listing using
\f[CR]dirlist2html\f[R] like FTP.
.PP
\f[CR]man:\f[R], \f[CR]man\-k:\f[R] and \f[CR]man\-l:\f[R] are wrappers
around the commands \f[CR]man\f[R], \f[CR]man \-k\f[R] and
\f[CR]man \-l\f[R].
These look up man pages using \f[CR]/usr/bin/man\f[R] and turn on\-page
references into links.
A wrapper command \f[CR]mancha\f[R] also exists; this has an interface
similar to \f[CR]man\f[R].
(This used to be based on w3mman2html.cgi, but it has been rewritten as
a standalone Nim program.)
.SS Internal schemes: cgi\-bin:, stream:, cache:, data:, about:
Five internal protocols exist: \f[CR]cgi\-bin:\f[R], \f[CR]stream:\f[R],
\f[CR]cache:\f[R], \f[CR]data:\f[R] and \f[CR]about:\f[R].
These are the basic building blocks for the implementation of every
protocol mentioned above; for this reason, these can \f[I]not\f[R] be
replaced, and are implemented in the main browser binary.
.PP
\f[CR]cgi\-bin:\f[R] executes a local CGI script.
This scheme is used for the actual implementation of the non\-internal
protocols mentioned above.
Local CGI scripts can also be used to implement wrappers of other
programs inside Chawan (e.g.\ dictionaries).
.PP
\f[CR]stream:\f[R] is used for streams returned by external programs.
It differs from \f[CR]cgi\-bin:\f[R] in that it does not cooperate with
the external process, and that the loader does not keep track of where
the stream originally comes from.
Therefore it is suitable for reading in the output of mailcap entries,
or for turning stdin into a URL.
.PP
It is not possible to reload \f[CR]stream:\f[R] URLs.
To support rewinding and \(lqview source\(rq, the output of
\f[CR]stream:\f[R]\(cqs is stored in a cache file until the buffer is
discarded.
.PP
\f[CR]cache:\f[R] is not something an end user would normally see;
it\(cqs used for rewinding or re\-interpreting streams already
downloaded.
.PP
Caching works differently than in most other browsers; files are
deterministically loaded from the cache upon certain actions, and from
the network upon others, but neither is used as a fallback to the other.
.PP
\f[CR]data:\f[R] decodes a data URL as defined in RFC 2397.
This used to be a CGI module, but has been moved back into the loader
process because these URLs can get so long that they no longer fit into
the environment.
.PP
\f[CR]about:\f[R] is inside the loader to allow for an implementation of
the download list panel.
It should be turned into a CGI module once the loader gets RPC
capabilities.
.PP
The following about pages are available: \f[CR]about:chawan\f[R],
\f[CR]about:blank\f[R], \f[CR]about:license\f[R],
\f[CR]about:downloads\f[R].
.SS Custom protocols
The \f[CR]cha\f[R] binary itself does not know much about the protocols
listed above; instead, it loads these through a combination of local
CGI, urimethodmap, and if conversion to HTML or plain text is necessary,
mailcap (using x\-htmloutput, x\-ansioutput and copiousoutput).
.PP
urimethodmap can also be used to override default handlers for the
protocols listed above.
This is similar to how w3m allows you to override the default directory
listing display, but much more powerful; this way, any library or
program that can retrieve and output text through a certain protocol can
be combined with Chawan.
.PP
For example, consider the urimethodmap definition of \f[CR]finger\f[R]:
.IP
.EX
finger:     cgi\-bin:finger
.EE
.PP
This commands Chawan to load the \f[CR]finger\f[R] CGI script, setting
the \f[CR]$MAPPED_URI_*\f[R] variables to the target URL\(cqs parts in
the process.
.PP
Then, finger uses these passed parts to construct an appropriate curl
command that will retrieve the specified \f[CR]finger:\f[R] URL; it
prints the header `Content\-Type: text/plain' to the output, then an
empty line, then the body of the retrieved resource.
If an error is encountered, it prints a \f[CR]Cha\-Control\f[R] header
with an error code and a specific error message instead.
.SS Adding a new protocol
Here we will add a protocol called \(lqcowsay\(rq, so that the URL
cowsay:text prints the output of \f[CR]cowsay text\f[R] after a second
of waiting.
.PP
\f[CR]mkdir \-p \(ti/.chawan/cgi\-bin\f[R], and create a CGI script in
\f[CR]\(ti/.chawan/cgi\-bin/cowsay.cgi\f[R]:
.IP
.EX
\f[I]#!/bin/sh\f[R]
\f[I]# We are going to wait a second from now, but want Chawan to show\f[R]
\f[I]# \(dqDownloading...\(dq instead of \(dqConnecting...\(dq. So signal to the browser\f[R]
\f[I]# that the connection has succeeded.\f[R]
printf \(aqCha\-Control: Connected\(rsn\(aq
sleep 1 \f[I]# sleep\f[R]
\f[I]# Status is a special header that signals the equivalent HTTP status code.\f[R]
printf \(aqStatus: 200\(aq \f[I]# HTTP OK\f[R]
\f[I]# Tell the browser that no more control headers are to be expected.\f[R]
\f[I]# This is only useful when you want to send remotely received headers;\f[R]
\f[I]# then, it would be an attack vector to simply send the headers without\f[R]
\f[I]# ControlDone, as nothing stops the website from sending a Cha\-Control\f[R]
\f[I]# header.  With ControlDone sent, subsequent Cha\-Control headers will be\f[R]
\f[I]# interpreted as regular headers.\f[R]
printf \(aqCha\-Control: ControlDone\(rsn\(aq
\f[I]# As in HTTP, you must send an empty line before the body.\f[R]
printf \(aq\(rsn\(aq
\f[I]# Now, print the body. We take the path passed to the URL; urimethodmap\f[R]
\f[I]# sets this as MAPPED_URI_PATH. This is URI\-encoded, so we also run the urldec\f[R]
\f[I]# utility on it.\f[R]
cowsay \(dq$(printf \(aq%s\(rsn\(aq \(dq$MAPPED_URI_PATH\(dq \f[B]|\f[R] \(dq$CHA_LIBEXEC_DIR\(dq/urldec)\(dq
.EE
.PP
Now, create a \(lq.urimethodmap\(rq file in your \f[CR]$HOME\f[R]
directory.
.PP
Then, enter into it the following:
.IP
.EX
cowsay:     /cgi\-bin/cowsay.cgi
.EE
.PP
Now try \f[CR]cha cowsay:Hello,%20world.\f[R].
If you did everything correctly, it should wait one second, then print a
cow saying \(lqHello, world.\(rq.
.SS See also
\f[B]cha\f[R](1), \f[B]cha\-localcgi\f[R](5),
\f[B]cha\-urimethodmap\f[R](5), \f[B]cha\-mailcap\f[R](5)
